@page "/"
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using System.Linq
@inject HttpClient Http
@inject NavigationManager NavManager

<PageTitle>PDF Browser</PageTitle>

<h1 class="mb-4">üìÅ PDF Browser</h1>

@if (!string.IsNullOrEmpty(linesError))
{
    <div class="alert alert-danger" role="alert">@linesError</div>
}
else if (isLoadingLines)
{
    <div class="text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå...</div>
}
else
{
    <div class="mb-4 d-flex flex-wrap gap-2">
        @foreach (var line in AllLines)
        {
            var isAvailable = availableLines.Contains(line);
            <button class="btn @(string.Equals(line, selectedLine, StringComparison.OrdinalIgnoreCase) ? "btn-primary" : "btn-outline-primary")"
                    disabled="@(!isAvailable || (isLoadingFiles && !string.Equals(line, selectedLine, StringComparison.OrdinalIgnoreCase)))"
                    @onclick="async () => await SelectLine(line)">
                @line
                @if (!isAvailable)
                {
                    <span class="ms-2 badge bg-secondary">‡πÑ‡∏°‡πà‡∏û‡∏ö</span>
                }
            </button>
        }
    </div>

    if (!availableLines.Any())
    {
        <div class="alert alert-warning" role="alert">
            ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå F1, F2 ‡∏´‡∏£‡∏∑‡∏≠ F3 ‡∏ö‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
        </div>
    }
}

@if (!string.IsNullOrEmpty(filesError))
{
    <div class="alert alert-danger" role="alert">@filesError</div>
}
else if (isLoadingFiles)
{
    <div class="text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå PDF...</div>
}
else if (selectedLine is not null)
{
    if (currentFiles is null)
    {
        <div class="text-muted">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡πÑ‡∏ü‡∏•‡πå PDF</div>
    }
    else
    {
        <nav class="mb-3" aria-label="breadcrumb">
            <ol class="breadcrumb mb-0">
                <li class="breadcrumb-item @(currentPathSegments.Count == 0 ? "active" : null)"
                    aria-current="@(currentPathSegments.Count == 0 ? "page" : null)">
                    @if (currentPathSegments.Count == 0)
                    {
                        @selectedLine
                    }
                    else
                    {
                        <button class="btn btn-link p-0"
                                type="button"
                                @onclick="async () => await NavigateToRootAsync()">@selectedLine</button>
                    }
                </li>
                @for (var i = 0; i < currentPathSegments.Count; i++)
                {
                    var folderName = currentPathSegments[i];
                    var isLast = i == currentPathSegments.Count - 1;
                    <li class="breadcrumb-item @(isLast ? "active" : null)"
                        aria-current="@(isLast ? "page" : null)">
                        @if (isLast)
                        {
                            @folderName
                        }
                        else
                        {
                            <button class="btn btn-link p-0"
                                    type="button"
                                    @onclick="async () => await NavigateToBreadcrumbAsync(i)">@folderName</button>
                        }
                    </li>
                }
            </ol>
        </nav>

        <div class="card mb-4">
            <div class="card-header">‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÉ‡∏ô @GetCurrentPathDisplay()</div>
            <div class="card-body d-flex flex-column flex-md-row gap-2 align-items-start align-items-md-center">
                <input class="form-control"
                       placeholder="‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå (‡πÄ‡∏ä‡πà‡∏ô Model A)"
                       @bind="newFolderName"
                       @bind:event="oninput"
                       disabled="@isCreatingFolder" />
                <button class="btn btn-outline-primary"
                        disabled="@(!CanCreateFolder)"
                        @onclick="CreateFolderAsync">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå</button>
            </div>
            @if (!string.IsNullOrEmpty(createFolderError))
            {
                <div class="card-footer text-danger">@createFolderError</div>
            }
            else if (!string.IsNullOrEmpty(createFolderSuccess))
            {
                <div class="card-footer text-success">@createFolderSuccess</div>
            }
        </div>

        <div class="card mb-4">
            <div class="card-header">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå PDF ‡∏•‡∏á‡πÉ‡∏ô @GetCurrentPathDisplay()</div>
            <div class="card-body d-flex flex-column flex-md-row gap-2 align-items-start align-items-md-center">
                <InputFile OnChange="HandleFileSelected" accept=".pdf" disabled="@isUploadingFile" />
                <div class="flex-grow-1">
                    @if (!string.IsNullOrEmpty(pendingFileName))
                    {
                        <div class="text-muted small">‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: @pendingFileName</div>
                    }
                    else
                    {
                        <div class="text-muted small">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå PDF ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î</div>
                    }
                </div>
                <button class="btn btn-success"
                        disabled="@(!CanUpload)"
                        @onclick="UploadSelectedFile">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå</button>
            </div>
            @if (!string.IsNullOrEmpty(uploadError))
            {
                <div class="card-footer text-danger">@uploadError</div>
            }
            else if (!string.IsNullOrEmpty(uploadSuccess))
            {
                <div class="card-footer text-success">@uploadSuccess</div>
            }
        </div>

        <div class="card mb-4">
            <div class="card-header">‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏†‡∏≤‡∏¢‡πÉ‡∏ô @GetCurrentPathDisplay()</div>
            <div class="list-group list-group-flush">
                @if (currentFolders.Count == 0)
                {
                    <div class="list-group-item text-muted">‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏¢‡πà‡∏≠‡∏¢</div>
                }
                else
                {
                    @foreach (var folder in currentFolders)
                    {
                        <div class="list-group-item d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <div class="text-break fw-semibold">@folder</div>
                            <button class="btn btn-sm btn-outline-primary"
                                    type="button"
                                    disabled="@isLoadingFiles"
                                    @onclick="async () => await EnterFolderAsync(folder)">‡πÄ‡∏õ‡∏¥‡∏î</button>
                        </div>
                    }
                }
            </div>
        </div>

        if (currentFiles.Count == 0)
        {
            <div class="alert alert-info" role="alert">‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå PDF</div>
        }
        else
        {
            <div class="list-group mb-4">
                @foreach (var file in currentFiles)
                {
                    <div class="list-group-item d-flex justify-content-between align-items-center flex-wrap gap-2">
                        <div class="text-break">@file</div>
                        <div class="d-flex gap-2">
                            <a class="btn btn-sm btn-outline-secondary"
                               href="@BuildPdfUrl(selectedLine!, file)"
                               target="_blank" rel="noopener noreferrer">‡πÄ‡∏õ‡∏¥‡∏î</a>
                            <button class="btn btn-sm btn-primary"
                                    type="button"
                                    @onclick="() => PreviewFile(file)">‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß</button>
                        </div>
                    </div>
                }
            </div>
        }
    }
}

@if (!string.IsNullOrEmpty(previewFile) && selectedLine is not null)
{
    <div class="card shadow-sm">
        <div class="card-header d-flex justify-content-between align-items-center">
            <div>
                <strong>Preview:</strong> @previewFile
            </div>
            <div class="d-flex gap-2">
                <a class="btn btn-sm btn-outline-secondary"
                   href="@BuildPdfUrl(selectedLine!, previewFile!)"
                   target="_blank" rel="noopener noreferrer">‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡πÉ‡∏´‡∏°‡πà</a>
                <button class="btn btn-sm btn-outline-danger" @onclick="ClosePreview">‡∏õ‡∏¥‡∏î‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß</button>
            </div>
        </div>
        <div class="card-body p-0">
            <iframe src="@BuildPdfUrl(selectedLine!, previewFile!)"
                    style="width:100%; height:70vh; border:0;"
                    title="PDF Preview"></iframe>
        </div>
    </div>
}

@code {
    private static readonly string[] AllLines = ["F1", "F2", "F3"];
    private const long MaxUploadBytes = 50L * 1024 * 1024;

    private readonly HashSet<string> availableLines = new(StringComparer.OrdinalIgnoreCase);
    private List<string>? currentFiles;
    private List<string> currentFolders = new();
    private List<string> currentPathSegments = new();
    private string? selectedLine;
    private string? previewFile;
    private bool isLoadingLines;
    private bool isLoadingFiles;
    private bool isUploadingFile;
    private bool isCreatingFolder;
    private string? linesError;
    private string? filesError;
    private string? uploadError;
    private string? uploadSuccess;
    private string? createFolderError;
    private string? createFolderSuccess;
    private IBrowserFile? pendingUpload;
    private string? pendingFileName;
    private string? newFolderName = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await LoadFoldersAsync();
    }

    private async Task LoadFoldersAsync()
    {
        try
        {
            isLoadingLines = true;
            linesError = null;
            var foldersEndpoint = NavManager.ToAbsoluteUri("/api/folders");
            var folders = await Http.GetFromJsonAsync<List<string>>(foldersEndpoint);
            availableLines.Clear();
            if (folders is not null)
            {
                foreach (var folder in folders)
                {
                    availableLines.Add(folder);
                }
            }
        }
        catch (Exception ex)
        {
            linesError = $"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ: {ex.Message}";
        }
        finally
        {
            isLoadingLines = false;
        }

        if (availableLines.Count > 0 && selectedLine is null)
        {
            var preferred = AllLines.FirstOrDefault(line => availableLines.Contains(line));
            if (preferred is not null)
            {
                await SelectLine(preferred);
            }
        }
    }

    private async Task SelectLine(string line)
    {
        if (!availableLines.Contains(line))
        {
            return;
        }

        selectedLine = line;
        previewFile = null;
        currentFiles = null;
        currentFolders = new List<string>();
        currentPathSegments = new List<string>();
        ResetUploadState();
        ResetFolderCreationState();
        filesError = null;
        await LoadFilesAsync(line, Array.Empty<string>());
    }

    private async Task LoadFilesAsync(string line, IReadOnlyList<string>? pathSegments = null)
    {
        var targetSegments = pathSegments is null
            ? new List<string>(currentPathSegments)
            : new List<string>(pathSegments);

        currentFiles = null;
        try
        {
            isLoadingFiles = true;
            filesError = null;
            var query = BuildPathQuery(targetSegments);
            var filesEndpoint = NavManager.ToAbsoluteUri($"/api/folders/{Uri.EscapeDataString(line)}{query}");
            var listing = await Http.GetFromJsonAsync<FolderListingResponse>(filesEndpoint);

            if (listing is null)
            {
                currentFolders = new List<string>();
                currentFiles = new List<string>();
                currentPathSegments = targetSegments;
                return;
            }

            currentFolders = listing.Folders is { } folders
                ? new List<string>(folders)
                : new List<string>();

            currentFiles = listing.Files is { } files
                ? new List<string>(files)
                : new List<string>();

            currentPathSegments = listing.PathSegments is { } pathList
                ? new List<string>(pathList)
                : new List<string>(targetSegments);
        }
        catch (Exception ex)
        {
            filesError = $"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ: {ex.Message}";
            currentFolders = new List<string>();
            currentFiles = new List<string>();
            currentPathSegments = targetSegments;
        }
        finally
        {
            isLoadingFiles = false;
        }
    }

    private void PreviewFile(string file)
    {
        previewFile = file;
    }

    private void ClosePreview()
    {
        previewFile = null;
    }

    private string BuildPdfUrl(string line, string file)
    {
        var baseUrl = $"/pdf/{Uri.EscapeDataString(line)}/{Uri.EscapeDataString(file)}";
        var query = BuildPathQuery(currentPathSegments);
        return string.IsNullOrEmpty(query) ? baseUrl : $"{baseUrl}{query}";
    }

    private string GetCurrentPathDisplay()
    {
        if (selectedLine is null)
        {
            return string.Empty;
        }

        return currentPathSegments.Count == 0
            ? selectedLine
            : $"{selectedLine}\\{string.Join('\\', currentPathSegments)}";
    }

    private async Task NavigateToRootAsync()
    {
        if (selectedLine is null)
        {
            return;
        }

        previewFile = null;
        await LoadFilesAsync(selectedLine, Array.Empty<string>());
    }

    private async Task NavigateToBreadcrumbAsync(int depth)
    {
        if (selectedLine is null)
        {
            return;
        }

        if (depth < 0 || depth >= currentPathSegments.Count)
        {
            return;
        }

        previewFile = null;
        var target = currentPathSegments.Take(depth + 1).ToList();
        await LoadFilesAsync(selectedLine, target);
    }

    private async Task EnterFolderAsync(string folder)
    {
        if (selectedLine is null || string.IsNullOrWhiteSpace(folder))
        {
            return;
        }

        previewFile = null;
        var target = new List<string>(currentPathSegments) { folder };
        await LoadFilesAsync(selectedLine, target);
    }

    private static string BuildPathQuery(IReadOnlyList<string> segments)
    {
        if (segments.Count == 0)
        {
            return string.Empty;
        }

        var encoded = string.Join('/', segments.Select(Uri.EscapeDataString));
        return $"?path={encoded}";
    }

    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        uploadError = null;
        uploadSuccess = null;
        pendingUpload = null;
        pendingFileName = null;

        var file = e.File;
        if (file is null)
        {
            uploadError = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å";
            return;
        }

        if (!file.Name.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase))
        {
            uploadError = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå PDF (.pdf)";
            return;
        }

        pendingUpload = file;
        pendingFileName = file.Name;
    }

    private bool CanUpload => selectedLine is not null && pendingUpload is not null && !isUploadingFile;

    private async Task UploadSelectedFile()
    {
        if (!CanUpload || selectedLine is null || pendingUpload is null)
        {
            return;
        }

        uploadError = null;
        uploadSuccess = null;
        isUploadingFile = true;

        try
        {
            var uploadEndpoint = NavManager.ToAbsoluteUri($"/api/folders/{Uri.EscapeDataString(selectedLine)}/upload{BuildPathQuery(currentPathSegments)}");
            using var content = new MultipartFormDataContent();
            var stream = pendingUpload.OpenReadStream(MaxUploadBytes);
            var streamContent = new StreamContent(stream);
            streamContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/pdf");
            content.Add(streamContent, "file", pendingUpload.Name);

            var response = await Http.PostAsync(uploadEndpoint, content);
            if (response.IsSuccessStatusCode)
            {
                var uploadedName = pendingFileName ?? pendingUpload.Name;
                uploadSuccess = string.IsNullOrEmpty(uploadedName)
                    ? "‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢"
                    : $"‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå {uploadedName} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢";
                await LoadFilesAsync(selectedLine, currentPathSegments);
                pendingUpload = null;
                pendingFileName = null;
            }
            else
            {
                uploadError = await ExtractErrorMessageAsync(response);
            }
        }
        catch (Exception ex)
        {
            uploadError = $"‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {ex.Message}";
        }
        finally
        {
            isUploadingFile = false;
        }
    }

    private void ResetUploadState()
    {
        isUploadingFile = false;
        uploadError = null;
        uploadSuccess = null;
        pendingUpload = null;
        pendingFileName = null;
    }

    private bool CanCreateFolder => selectedLine is not null && !string.IsNullOrWhiteSpace(newFolderName) && !isCreatingFolder;

    private async Task CreateFolderAsync()
    {
        if (selectedLine is null)
        {
            return;
        }

        var desiredName = newFolderName?.Trim();
        if (string.IsNullOrWhiteSpace(desiredName))
        {
            createFolderError = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå";
            createFolderSuccess = null;
            return;
        }

        isCreatingFolder = true;
        createFolderError = null;
        createFolderSuccess = null;

        try
        {
            var endpoint = NavManager.ToAbsoluteUri($"/api/folders/{Uri.EscapeDataString(selectedLine)}/subfolders{BuildPathQuery(currentPathSegments)}");
            var response = await Http.PostAsJsonAsync(endpoint, new { name = desiredName });

            if (response.IsSuccessStatusCode)
            {
                createFolderSuccess = $"‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå {desiredName} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢";
                newFolderName = string.Empty;
                await LoadFilesAsync(selectedLine, currentPathSegments);
            }
            else
            {
                createFolderError = await ExtractErrorMessageAsync(response);
            }
        }
        catch (Exception ex)
        {
            createFolderError = $"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ: {ex.Message}";
        }
        finally
        {
            isCreatingFolder = false;
        }
    }

    private void ResetFolderCreationState()
    {
        isCreatingFolder = false;
        createFolderError = null;
        createFolderSuccess = null;
        newFolderName = string.Empty;
    }

    private sealed class FolderListingResponse
    {
        public List<string> PathSegments { get; set; } = new();
        public List<string> Folders { get; set; } = new();
        public List<string> Files { get; set; } = new();
    }

    private static async Task<string> ExtractErrorMessageAsync(HttpResponseMessage response)
    {
        var message = await response.Content.ReadAsStringAsync();
        var mediaType = response.Content.Headers.ContentType?.MediaType;

        if (string.Equals(mediaType, "application/problem+json", StringComparison.OrdinalIgnoreCase))
        {
            try
            {
                using var doc = JsonDocument.Parse(message);
                if (doc.RootElement.TryGetProperty("detail", out var detail) && detail.ValueKind == JsonValueKind.String)
                {
                    var detailValue = detail.GetString();
                    if (!string.IsNullOrWhiteSpace(detailValue))
                    {
                        return detailValue!;
                    }
                }

                if (doc.RootElement.TryGetProperty("title", out var title) && title.ValueKind == JsonValueKind.String)
                {
                    var titleValue = title.GetString();
                    if (!string.IsNullOrWhiteSpace(titleValue))
                    {
                        return titleValue!;
                    }
                }
            }
            catch (JsonException)
            {
                // ignore parsing failures and fall back to the raw message
            }
        }

        if (string.IsNullOrWhiteSpace(message))
        {
            message = $"‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏£‡∏´‡∏±‡∏™ {response.StatusCode})";
        }

        return message;
    }
}

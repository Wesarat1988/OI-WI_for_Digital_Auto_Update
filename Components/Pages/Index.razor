@page "/"
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using System.Text.Json
@using System.Linq
@inject HttpClient Http
@inject NavigationManager NavManager
@rendermode InteractiveServer

<PageTitle>PDF Browser</PageTitle>

<h1 class="mb-4">üìÅ PDF Browser</h1>

@if (!string.IsNullOrEmpty(linesError))
{
    <div class="alert alert-danger" role="alert">@linesError</div>
}
@else if (isLoadingLines)
{
    <div class="text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå...</div>
}
@else
{
    <div class="mb-4 d-flex flex-wrap gap-2">
        @foreach (var line in AllLines)
        {
            var isAvailable = availableLines.Contains(line);
            <button class="btn @(string.Equals(line, selectedLine, StringComparison.OrdinalIgnoreCase) ? "btn-primary" : "btn-outline-primary")"
                    disabled="@(!isAvailable || (isLoadingFiles && !string.Equals(line, selectedLine, StringComparison.OrdinalIgnoreCase)))"
                    @onclick="async () => await SelectLine(line)">
                @line
                @if (!isAvailable)
                {
                    <span class="ms-2 badge bg-secondary">‡πÑ‡∏°‡πà‡∏û‡∏ö</span>
                }
            </button>
        }
    </div>

    @if (!availableLines.Any())
    {
        <div class="alert alert-warning" role="alert">
            ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå F1, F2 ‡∏´‡∏£‡∏∑‡∏≠ F3 ‡∏ö‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå
        </div>
    }
}

@if (!string.IsNullOrEmpty(filesError))
{
    <div class="alert alert-danger" role="alert">@filesError</div>
}
@else if (isLoadingFiles)
{
    <div class="text-muted">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå PDF...</div>
}
@else if (selectedLine is not null)
{
    @if (currentDocuments is null)
    {
        <div class="text-muted">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡πÑ‡∏ü‡∏•‡πå PDF</div>
    }
    @else
    {
        <nav class="mb-3" aria-label="breadcrumb">
            <ol class="breadcrumb mb-0">
                <li class="breadcrumb-item @(currentPathSegments.Count == 0 ? "active" : null)"
                    aria-current="@(currentPathSegments.Count == 0 ? "page" : null)">
                    @if (currentPathSegments.Count == 0)
                    {
                        @selectedLine
                    }
                    @else
                    {
                        <button class="btn btn-link p-0"
                                type="button"
                                @onclick="async () => await NavigateToRootAsync()">@selectedLine</button>
                    }
                </li>
                @for (var i = 0; i < currentPathSegments.Count; i++)
                {
                    var folderName = currentPathSegments[i];
                    var isLast = i == currentPathSegments.Count - 1;
                    <li class="breadcrumb-item @(isLast ? "active" : null)"
                        aria-current="@(isLast ? "page" : null)">
                        @if (isLast)
                        {
                            @folderName
                        }
                        @else
                        {
                            <button class="btn btn-link p-0"
                                    type="button"
                                    @onclick="async () => await NavigateToBreadcrumbAsync(i)">@folderName</button>
                        }
                    </li>
                }
            </ol>
        </nav>

        <div class="card mb-4">
            <div class="card-header">‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÉ‡∏ô @GetCurrentPathDisplay()</div>
            <div class="card-body d-flex flex-column flex-md-row gap-2 align-items-start align-items-md-center">
                <input class="form-control"
                       placeholder="‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå (‡πÄ‡∏ä‡πà‡∏ô Model A)"
                       @bind="newFolderName"
                       @bind:event="oninput"
                       disabled="@isCreatingFolder" />
                <button class="btn btn-outline-primary"
                        disabled="@(!CanCreateFolder)"
                        @onclick="CreateFolderAsync">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå</button>
            </div>
            @if (!string.IsNullOrEmpty(createFolderError))
            {
                <div class="card-footer text-danger">@createFolderError</div>
            }
            @else if (!string.IsNullOrEmpty(createFolderSuccess))
            {
                <div class="card-footer text-success">@createFolderSuccess</div>
            }
        </div>

        <div class="card mb-4">
            <div class="card-header">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå PDF ‡∏•‡∏á‡πÉ‡∏ô @GetCurrentPathDisplay()</div>
            <div class="card-body">
                <div class="row g-2 align-items-center">
                    <div class="col-12 col-md-auto">
                        <InputFile OnChange="HandleFileSelected" accept=".pdf" disabled="@isUploadingFile" />
                    </div>
                    <div class="col">
                        @if (!string.IsNullOrEmpty(pendingFileName))
                        {
                            <div class="text-muted small">‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: @pendingFileName</div>
                        }
                        @else
                        {
                            <div class="text-muted small">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå PDF ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î</div>
                        }
                    </div>
                    <div class="col-12 col-md-auto d-flex">
                        <button class="btn btn-success w-100"
                                disabled="@(!CanUpload)"
                                @onclick="UploadSelectedFile">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏ü‡∏•‡πå</button>
                    </div>
                </div>
                <div class="mt-3">
                    <textarea class="form-control"
                              rows="2"
                              placeholder="‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°"
                              @bind="uploadComment"
                              @bind:event="oninput"
                              disabled="@isUploadingFile"></textarea>
                    <div class="form-text">‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡πå‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà</div>
                </div>
            </div>
            @if (!string.IsNullOrEmpty(uploadError))
            {
                <div class="card-footer text-danger">@uploadError</div>
            }
            @else if (!string.IsNullOrEmpty(uploadSuccess))
            {
                <div class="card-footer text-success">@uploadSuccess</div>
            }
        </div>

        <div class="card mb-4">
            <div class="card-header">‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏†‡∏≤‡∏¢‡πÉ‡∏ô @GetCurrentPathDisplay()</div>
            <div class="list-group list-group-flush">
                @if (currentFolders.Count == 0)
                {
                    <div class="list-group-item text-muted">‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏¢‡πà‡∏≠‡∏¢</div>
                }
                @else
                {
                    @foreach (var folder in currentFolders)
                    {
                        <div class="list-group-item d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <div class="text-break fw-semibold">@folder</div>
                            <button class="btn btn-sm btn-outline-primary"
                                    type="button"
                                    disabled="@isLoadingFiles"
                                    @onclick="async () => await EnterFolderAsync(folder)">‡πÄ‡∏õ‡∏¥‡∏î</button>
                        </div>
                    }
                }
            </div>
        </div>

        @if (currentDocuments.Count == 0)
        {
            <div class="alert alert-info" role="alert">‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå PDF</div>
        }
        @else
        {
            <div class="list-group mb-4">
                @foreach (var document in currentDocuments)
                {
                    @{ var selectedVersion = GetSelectedVersion(document); }
                    <div class="list-group-item">
                        <div class="d-flex flex-column flex-lg-row justify-content-between gap-3">
                            <div class="flex-grow-1">
                                <div class="fw-semibold">@document.BaseName</div>
                                @if (selectedVersion is not null)
                                {
                                    <div class="small text-muted">
                                        Division @selectedVersion.Division.ToString("D2") ‚Ä¢ @selectedVersion.UploadedUtc.ToLocalTime().ToString("g")
                                    </div>
                                    @if (!string.IsNullOrWhiteSpace(selectedVersion.Comment))
                                    {
                                        <div class="small text-muted">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: @selectedVersion.Comment</div>
                                    }
                                }
                                @else
                                {
                                    <div class="small text-muted">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î</div>
                                }
                            </div>
                            <div class="d-flex flex-column flex-md-row align-items-stretch align-items-md-center gap-2">
                                <select class="form-select form-select-sm"
                                        disabled="@(document.Versions.Count == 0)"
                                        value="@(selectedVersion?.FileName)"
                                        @onchange="e => ChangeSelectedVersion(document, e.Value?.ToString())">
                                    @foreach (var version in document.Versions)
                                    {
                                        <option value="@version.FileName">@FormatVersionLabel(version)</option>
                                    }
                                </select>
                                <a class="btn btn-sm btn-outline-secondary @(selectedVersion is null ? "disabled" : string.Empty)"
                                   href="@(selectedVersion is not null ? BuildPdfUrl(selectedLine!, selectedVersion.FileName) : "#")"
                                   target="_blank"
                                   rel="noopener noreferrer"
                                   tabindex="@(selectedVersion is null ? -1 : 0)">
                                    ‡πÄ‡∏õ‡∏¥‡∏î
                                </a>
                                <button class="btn btn-sm btn-primary"
                                        type="button"
                                        disabled="@(selectedVersion is null)"
                                        @onclick="() => PreviewDocument(document)">
                                    ‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß
                                </button>
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
    }
}

@if (previewVersion is not null && previewBaseName is not null && selectedLine is not null)
{
    <div class="card shadow-sm">
        <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
            <div class="d-flex align-items-center gap-2">
                <strong>Preview:</strong>
                <span>@previewBaseName</span>
                <span class="badge bg-primary">Division @previewVersion.Division.ToString("D2")</span>
            </div>
            <div class="d-flex gap-2">
                <a class="btn btn-sm btn-outline-secondary"
                   href="@BuildPdfUrl(selectedLine!, previewVersion.FileName)"
                   target="_blank" rel="noopener noreferrer">‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡πÉ‡∏´‡∏°‡πà</a>
                <button class="btn btn-sm btn-outline-danger" @onclick="ClosePreview">‡∏õ‡∏¥‡∏î‡∏û‡∏£‡∏µ‡∏ß‡∏¥‡∏ß</button>
            </div>
        </div>
        <div class="card-body p-0">
            <div class="px-3 py-2 border-bottom bg-light">
                <div class="small text-muted">‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î: @previewVersion.UploadedUtc.ToLocalTime().ToString("g")</div>
                @if (!string.IsNullOrWhiteSpace(previewVersion.Comment))
                {
                    <div class="small">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: @previewVersion.Comment</div>
                }
            </div>
            <iframe src="@BuildPdfUrl(selectedLine!, previewVersion.FileName)"
                    style="width:100%; height:70vh; border:0;"
                    title="PDF Preview"></iframe>
        </div>
    </div>
}

@code {
    private static readonly string[] AllLines = ["F1", "F2", "F3"];
    private const long MaxUploadBytes = 50L * 1024 * 1024;

    private readonly HashSet<string> availableLines = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, VersionResponse> selectedDocumentVersions = new(StringComparer.OrdinalIgnoreCase);
    private List<DocumentResponse>? currentDocuments;
    private List<string> currentFolders = new();
    private List<string> currentPathSegments = new();
    private string? selectedLine;
    private string? previewBaseName;
    private VersionResponse? previewVersion;
    private bool isLoadingLines;
    private bool isLoadingFiles;
    private bool isUploadingFile;
    private bool isCreatingFolder;
    private string? linesError;
    private string? filesError;
    private string? uploadError;
    private string? uploadSuccess;
    private string? createFolderError;
    private string? createFolderSuccess;
    private IBrowserFile? pendingUpload;
    private string? pendingFileName;
    private string? newFolderName = string.Empty;
    private string uploadComment = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await LoadFoldersAsync();
    }

    private async Task LoadFoldersAsync()
    {
        try
        {
            isLoadingLines = true;
            linesError = null;
            var foldersEndpoint = NavManager.ToAbsoluteUri("/api/folders");
            var folders = await Http.GetFromJsonAsync<List<string>>(foldersEndpoint);
            availableLines.Clear();
            if (folders is not null)
            {
                foreach (var folder in folders)
                {
                    availableLines.Add(folder);
                }
            }
        }
        catch (Exception ex)
        {
            linesError = $"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ: {ex.Message}";
        }
        finally
        {
            isLoadingLines = false;
        }

        if (availableLines.Count > 0 && selectedLine is null)
        {
            var preferred = AllLines.FirstOrDefault(line => availableLines.Contains(line));
            if (preferred is not null)
            {
                await SelectLine(preferred);
            }
        }
    }

    private async Task SelectLine(string line)
    {
        if (!availableLines.Contains(line))
        {
            return;
        }

        selectedLine = line;
        previewBaseName = null;
        previewVersion = null;
        currentDocuments = null;
        currentFolders = new List<string>();
        currentPathSegments = new List<string>();
        selectedDocumentVersions.Clear();
        ResetUploadState();
        ResetFolderCreationState();
        filesError = null;
        await LoadFilesAsync(line, Array.Empty<string>());
    }

    private async Task LoadFilesAsync(string line, IReadOnlyList<string>? pathSegments = null)
    {
        var targetSegments = pathSegments is null
            ? new List<string>(currentPathSegments)
            : new List<string>(pathSegments);

        currentDocuments = null;
        try
        {
            isLoadingFiles = true;
            filesError = null;
            var query = BuildPathQuery(targetSegments);
            var filesEndpoint = NavManager.ToAbsoluteUri($"/api/folders/{Uri.EscapeDataString(line)}{query}");
            var listing = await Http.GetFromJsonAsync<FolderListingResponse>(filesEndpoint);

            if (listing is null)
            {
                currentFolders = new List<string>();
                currentDocuments = new List<DocumentResponse>();
                currentPathSegments = targetSegments;
                selectedDocumentVersions.Clear();
                return;
            }

            currentFolders = listing.Folders is { } folders
                ? new List<string>(folders)
                : new List<string>();

            currentDocuments = listing.Documents is { } documents
                ? new List<DocumentResponse>(documents)
                : new List<DocumentResponse>();

            currentPathSegments = listing.PathSegments is { } pathList
                ? new List<string>(pathList)
                : new List<string>(targetSegments);

            selectedDocumentVersions.Clear();

            foreach (var document in currentDocuments)
            {
                document.Versions ??= new List<VersionResponse>();
                var defaultVersion = document.Versions
                    .OrderByDescending(v => v.Division)
                    .ThenByDescending(v => v.UploadedUtc)
                    .FirstOrDefault();

                if (defaultVersion is not null)
                {
                    selectedDocumentVersions[document.BaseName] = defaultVersion;
                }
            }

            SyncPreviewAfterReload();
        }
        catch (Exception ex)
        {
            filesError = $"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ: {ex.Message}";
            currentFolders = new List<string>();
            currentDocuments = new List<DocumentResponse>();
            currentPathSegments = targetSegments;
            selectedDocumentVersions.Clear();
            previewBaseName = null;
            previewVersion = null;
        }
        finally
        {
            isLoadingFiles = false;
        }
    }

    private VersionResponse? GetSelectedVersion(DocumentResponse document)
    {
        if (selectedDocumentVersions.TryGetValue(document.BaseName, out var version))
        {
            return version;
        }

        var fallback = document.Versions
            .OrderByDescending(v => v.Division)
            .ThenByDescending(v => v.UploadedUtc)
            .FirstOrDefault();

        if (fallback is not null)
        {
            selectedDocumentVersions[document.BaseName] = fallback;
        }

        return fallback;
    }

    private void ChangeSelectedVersion(DocumentResponse document, string? fileName)
    {
        if (string.IsNullOrWhiteSpace(fileName))
        {
            return;
        }

        var version = document.Versions
            .FirstOrDefault(v => string.Equals(v.FileName, fileName, StringComparison.OrdinalIgnoreCase));

        if (version is null)
        {
            return;
        }

        selectedDocumentVersions[document.BaseName] = version;

        if (previewBaseName is not null && string.Equals(previewBaseName, document.BaseName, StringComparison.OrdinalIgnoreCase))
        {
            previewVersion = version;
        }
    }

    private void PreviewDocument(DocumentResponse document)
    {
        var version = GetSelectedVersion(document);
        if (version is null)
        {
            return;
        }

        previewBaseName = document.BaseName;
        previewVersion = version;
    }

    private void ClosePreview()
    {
        previewBaseName = null;
        previewVersion = null;
    }

    private static string FormatVersionLabel(VersionResponse version)
    {
        var divisionLabel = $"Division {version.Division:D2}";
        var timestamp = version.UploadedUtc.ToLocalTime().ToString("g");

        if (string.IsNullOrWhiteSpace(version.Comment))
        {
            return $"{divisionLabel} ‚Ä¢ {timestamp}";
        }

        var comment = version.Comment.Length > 40
            ? version.Comment.Substring(0, 40) + "‚Ä¶"
            : version.Comment;

        return $"{divisionLabel} ‚Ä¢ {timestamp} ‚Ä¢ {comment}";
    }

    private string BuildPdfUrl(string line, string file)
    {
        var baseUrl = $"/pdf/{Uri.EscapeDataString(line)}/{Uri.EscapeDataString(file)}";
        var query = BuildPathQuery(currentPathSegments);
        return string.IsNullOrEmpty(query) ? baseUrl : $"{baseUrl}{query}";
    }

    private void SyncPreviewAfterReload()
    {
        if (previewBaseName is null || currentDocuments is null)
        {
            previewBaseName = null;
            previewVersion = null;
            return;
        }

        var document = currentDocuments.FirstOrDefault(d => string.Equals(d.BaseName, previewBaseName, StringComparison.OrdinalIgnoreCase));
        if (document is null)
        {
            previewBaseName = null;
            previewVersion = null;
            return;
        }

        VersionResponse? updatedVersion = null;

        if (previewVersion is not null)
        {
            updatedVersion = document.Versions
                .FirstOrDefault(v => string.Equals(v.FileName, previewVersion.FileName, StringComparison.OrdinalIgnoreCase));
        }

        updatedVersion ??= GetSelectedVersion(document);

        if (updatedVersion is null)
        {
            previewBaseName = null;
            previewVersion = null;
        }
        else
        {
            previewVersion = updatedVersion;
        }
    }

    private string GetCurrentPathDisplay()
    {
        if (selectedLine is null)
        {
            return string.Empty;
        }

        return currentPathSegments.Count == 0
            ? selectedLine
            : $"{selectedLine}\\{string.Join('\\', currentPathSegments)}";
    }

    private async Task NavigateToRootAsync()
    {
        if (selectedLine is null)
        {
            return;
        }

        previewBaseName = null;
        previewVersion = null;
        await LoadFilesAsync(selectedLine, Array.Empty<string>());
    }

    private async Task NavigateToBreadcrumbAsync(int depth)
    {
        if (selectedLine is null)
        {
            return;
        }

        if (depth < 0 || depth >= currentPathSegments.Count)
        {
            return;
        }

        previewBaseName = null;
        previewVersion = null;
        var target = currentPathSegments.Take(depth + 1).ToList();
        await LoadFilesAsync(selectedLine, target);
    }

    private async Task EnterFolderAsync(string folder)
    {
        if (selectedLine is null || string.IsNullOrWhiteSpace(folder))
        {
            return;
        }

        previewBaseName = null;
        previewVersion = null;
        var target = new List<string>(currentPathSegments) { folder };
        await LoadFilesAsync(selectedLine, target);
    }

    private static string BuildPathQuery(IReadOnlyList<string> segments)
    {
        if (segments.Count == 0)
        {
            return string.Empty;
        }

        var encoded = string.Join('/', segments.Select(Uri.EscapeDataString));
        return $"?path={encoded}";
    }

    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        uploadError = null;
        uploadSuccess = null;
        pendingUpload = null;
        pendingFileName = null;

        var file = e.File;
        if (file is null)
        {
            uploadError = "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å";
            return;
        }

        if (!file.Name.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase))
        {
            uploadError = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå PDF (.pdf)";
            return;
        }

        pendingUpload = file;
        pendingFileName = file.Name;
    }

    private bool CanUpload => selectedLine is not null && pendingUpload is not null && !isUploadingFile && !string.IsNullOrWhiteSpace(uploadComment);

    private async Task UploadSelectedFile()
    {
        if (!CanUpload || selectedLine is null || pendingUpload is null)
        {
            return;
        }

        var comment = uploadComment?.Trim();
        if (string.IsNullOrWhiteSpace(comment))
        {
            uploadError = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î";
            uploadSuccess = null;
            return;
        }

        uploadError = null;
        uploadSuccess = null;
        isUploadingFile = true;

        try
        {
            var uploadEndpoint = NavManager.ToAbsoluteUri($"/api/folders/{Uri.EscapeDataString(selectedLine)}/upload{BuildPathQuery(currentPathSegments)}");
            using var content = new MultipartFormDataContent();
            var stream = pendingUpload.OpenReadStream(MaxUploadBytes);
            var streamContent = new StreamContent(stream);
            streamContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/pdf");
            content.Add(streamContent, "file", pendingUpload.Name);
            content.Add(new StringContent(comment), "comment");

            var response = await Http.PostAsync(uploadEndpoint, content);
            if (response.IsSuccessStatusCode)
            {
                var uploadInfo = await response.Content.ReadFromJsonAsync<UploadResponse>();
                if (uploadInfo is not null && !string.IsNullOrWhiteSpace(uploadInfo.BaseName))
                {
                    uploadSuccess = $"‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î Division {uploadInfo.Division:D2} ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {uploadInfo.BaseName} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢";
                }
                else
                {
                    var uploadedName = pendingFileName ?? pendingUpload.Name;
                    uploadSuccess = string.IsNullOrEmpty(uploadedName)
                        ? "‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢"
                        : $"‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå {uploadedName} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢";
                }
                await LoadFilesAsync(selectedLine, currentPathSegments);
                pendingUpload = null;
                pendingFileName = null;
                uploadComment = string.Empty;
            }
            else
            {
                uploadError = await ExtractErrorMessageAsync(response);
            }
        }
        catch (Exception ex)
        {
            uploadError = $"‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {ex.Message}";
        }
        finally
        {
            isUploadingFile = false;
        }
    }

    private void ResetUploadState()
    {
        isUploadingFile = false;
        uploadError = null;
        uploadSuccess = null;
        pendingUpload = null;
        pendingFileName = null;
        uploadComment = string.Empty;
    }

    private bool CanCreateFolder => selectedLine is not null && !string.IsNullOrWhiteSpace(newFolderName) && !isCreatingFolder;

    private async Task CreateFolderAsync()
    {
        if (selectedLine is null)
        {
            return;
        }

        var desiredName = newFolderName?.Trim();
        if (string.IsNullOrWhiteSpace(desiredName))
        {
            createFolderError = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå";
            createFolderSuccess = null;
            return;
        }

        isCreatingFolder = true;
        createFolderError = null;
        createFolderSuccess = null;

        try
        {
            var endpoint = NavManager.ToAbsoluteUri($"/api/folders/{Uri.EscapeDataString(selectedLine)}/subfolders{BuildPathQuery(currentPathSegments)}");
            var response = await Http.PostAsJsonAsync(endpoint, new { name = desiredName });

            if (response.IsSuccessStatusCode)
            {
                createFolderSuccess = $"‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå {desiredName} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢";
                newFolderName = string.Empty;
                await LoadFilesAsync(selectedLine, currentPathSegments);
            }
            else
            {
                createFolderError = await ExtractErrorMessageAsync(response);
            }
        }
        catch (Exception ex)
        {
            createFolderError = $"‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ: {ex.Message}";
        }
        finally
        {
            isCreatingFolder = false;
        }
    }

    private void ResetFolderCreationState()
    {
        isCreatingFolder = false;
        createFolderError = null;
        createFolderSuccess = null;
        newFolderName = string.Empty;
    }

    private sealed class FolderListingResponse
    {
        public List<string> PathSegments { get; set; } = new();
        public List<string> Folders { get; set; } = new();
        public List<string> Files { get; set; } = new();
        public List<DocumentResponse> Documents { get; set; } = new();
    }

    private sealed class DocumentResponse
    {
        public string BaseName { get; set; } = string.Empty;
        public List<VersionResponse> Versions { get; set; } = new();
    }

    private sealed class VersionResponse
    {
        public string FileName { get; set; } = string.Empty;
        public int Division { get; set; }
        public DateTime UploadedUtc { get; set; }
        public string Comment { get; set; } = string.Empty;
    }

    private sealed class UploadResponse
    {
        public string File { get; set; } = string.Empty;
        public string BaseName { get; set; } = string.Empty;
        public int Division { get; set; }
        public string Comment { get; set; } = string.Empty;
        public DateTime UploadedUtc { get; set; }
    }

    private static async Task<string> ExtractErrorMessageAsync(HttpResponseMessage response)
    {
        var message = await response.Content.ReadAsStringAsync();
        var mediaType = response.Content.Headers.ContentType?.MediaType;

        if (string.Equals(mediaType, "application/problem+json", StringComparison.OrdinalIgnoreCase))
        {
            try
            {
                using var doc = JsonDocument.Parse(message);
                if (doc.RootElement.TryGetProperty("detail", out var detail) && detail.ValueKind == JsonValueKind.String)
                {
                    var detailValue = detail.GetString();
                    if (!string.IsNullOrWhiteSpace(detailValue))
                    {
                        return detailValue!;
                    }
                }

                if (doc.RootElement.TryGetProperty("title", out var title) && title.ValueKind == JsonValueKind.String)
                {
                    var titleValue = title.GetString();
                    if (!string.IsNullOrWhiteSpace(titleValue))
                    {
                        return titleValue!;
                    }
                }
            }
            catch (JsonException)
            {
                // ignore parsing failures and fall back to the raw message
            }
        }

        if (string.IsNullOrWhiteSpace(message))
        {
            message = $"‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡∏£‡∏´‡∏±‡∏™ {response.StatusCode})";
        }

        return message;
    }
}
